name: front-actions
run-name: front-actions (@${{ github.triggering_actor }})

on:
  push:
    branches:
      - cloud-configs

jobs:

  all-up: # [UP]
    name: Infra + front k8s up
    if: startsWith(github.event.head_commit.message, '[UP]')
    runs-on: ubuntu-latest
    environment: front
    steps:

    # Checkout de la rama. 
    - name: Checkout code
      uses: actions/checkout@v3

    # Crea los archivos necesarios para los siguientes pasos.
    - name: file creation
      working-directory: src
      run: |

        # Crea los secretos para que Terraform se conecte a GCP.
        echo -n '${{ secrets.GOOGLE_CREDENTIALS }}' > terraform/gcloud-key.json

        # Guarda el token en un archivo para que lo utilice Terraform.
        echo -n '${{ secrets.CLOUDFLARE_TF_TOKEN }}' > terraform/cloudflare-token.txt

        # Crea los secretos para el certificado TLS.
        echo -n '${{ secrets.TLS_SECRET_YAML }}' > k8s/tls-secrets.yaml

        # Crea los secretos de Cloudflare para cert-manager.
        echo -n '${{ secrets.CLOUDFLARE_SECRET_YAML }}' > k8s/04-tls/dns01/01-cloudflare-secrets.yaml

    # Instala y configura Terraform CLI.
    - name: Terraform setup
      uses: hashicorp/setup-terraform@v2
        
    # Crea la infraestructura base en la nube.
    - name: Terraform init
      working-directory: src/terraform/00-base
      run: |

        terraform init --reconfigure \
          --backend-config bucket="spgda-bucket" \
          --backend-config prefix="state/base" \
          --backend-config credentials=$(dirname $(pwd))"/gcloud-key.json"

        terraform validate

        terraform plan -lock=false

        terraform apply -lock=false --auto-approve
    
    # Obtiene el archivo config de Kubernetes, que habilita el uso de kubectl.
    - name: Google Cloud authentication
      uses: google-github-actions/auth@v1
      with:
        credentials_json: ${{ secrets.GOOGLE_CREDENTIALS }}
    - name: Google Cloud SDK setup
      uses: google-github-actions/setup-gcloud@v1
      with:
        version: '>= 363.0.0'
        install_components: 'kubectl'
    - name: GCloud config
      run: |
        gcloud info

        gcloud components list

        gcloud container clusters get-credentials primary --region=us-central1-a
  
    # Despliega los objectos en la nube.
    - name: Kubernetes deploy
      working-directory: src/k8s
      run: |

        set -e
        
        echo "Aplicando los cambios de Kubernetes..."

        # Aplica los cambios de la primera tanda de archivos de configuración de Kubernetes.
        kubectl apply \
          -f 01-deploy-front.yaml \
          -f 02-service-front.yaml \
          -f 03-nginx-ingress/common/ns-and-sa.yaml \
          -f 03-nginx-ingress/rbac/rbac.yaml \
          -f tls-secrets.yaml \
          -f 03-nginx-ingress/common/nginx-config.yaml \
          -f 03-nginx-ingress/common/ingress-class.yaml \
          -f 03-nginx-ingress/common/crds/k8s.nginx.org_virtualservers.yaml \
          -f 03-nginx-ingress/common/crds/k8s.nginx.org_virtualserverroutes.yaml \
          -f 03-nginx-ingress/common/crds/k8s.nginx.org_transportservers.yaml \
          -f 03-nginx-ingress/common/crds/k8s.nginx.org_policies.yaml \
          -f 03-nginx-ingress/deployment/nginx-ingress.yaml \
          -f 03-nginx-ingress/app-ingress.yaml \
          -f 03-nginx-ingress/service/loadbalancer.yaml \
          -f 04-tls/dns01/00-cert-manager.yaml \
          -f 04-tls/dns01/01-cloudflare-secrets.yaml

        # Espera hasta que los objetos del cert-manager estén listos. [https://kubernetes.github.io/ingress-nginx/deploy/#pre-flight-check]
        echo "Esperando a que cert-manager esté listo..."
        kubectl wait --namespace cert-manager \
          --for=condition=ready pod \
          --selector=app=cert-manager \
          --timeout=120s
        kubectl wait --namespace cert-manager \
          --for=condition=ready pod \
          --selector=app=webhook \
          --timeout=120s
        kubectl wait --namespace cert-manager \
          --for=condition=ready pod \
          --selector=app=cainjector \
          --timeout=120s
        echo "cert-manager listo."

        # Aplica los cambios de la segunda tanda de archivos de configuración de Kubernetes.
        kubectl apply \
          -f 04-tls/dns01/02-issuer.yaml \
          -f 04-tls/dns01/03-certificate.yaml

        echo "Cambios aplicados."

        # Espera hasta que el controlador NGINX esté listo. [https://kubernetes.github.io/ingress-nginx/deploy/#pre-flight-check]
        echo "Se verifica que el controlador NGINX esté listo..."
        kubectl wait --namespace nginx-ingress \
          --for=condition=ready pod \
          --selector=app=nginx-ingress \
          --timeout=120s
        echo "Controlador listo."

    # Configura los servidores de nombre de dominio.
    - name: Terraform DNS config
      working-directory: src/terraform
      run: |

        terraform init --reconfigure \
          --backend-config bucket="spgda-bucket" \
          --backend-config prefix="state/dns" \
          --backend-config credentials=$(dirname $(pwd))"/gcloud-key.json"

        terraform validate

        sudo apt-get install jq
        
        echo "Verificando que el balanceador de cargas esté activo..."

        # Espera hasta que el balanceador de carga exista.
        until
          kubectl get service nginx-ingress --namespace=nginx-ingress
        do
          echo
          echo "El balanceador de cargas no está activo aún..."
          echo
          sleep 10
        done

        # Espera hasta que el balanceador de carga tenga IP pública.
        while 
          LOADBALANCER_IP=$(kubectl get -o json service nginx-ingress --namespace=nginx-ingress | jq -r .status.loadBalancer.ingress\[0\].ip)
          [ $LOADBALANCER_IP = null ]
        do
          echo
          echo "Todavía no se pudo obtener la IP pública del balanceador de cargas..."
          echo
          sleep 10
        done

        echo
        echo "IP pública del balanceador de cargas = $LOADBALANCER_IP."
        echo

        # Exporta las variables para que estén disponibles para los scripts de Terraform.
        export TF_VAR_LOADBALANCER_IP=$LOADBALANCER_IP

        terraform plan -lock=false

        terraform apply -lock=false --auto-approve
   
  all-down: # [DOWN]
    name: Infra down
    if: startsWith(github.event.head_commit.message, '[DOWN]')
    runs-on: ubuntu-latest
    environment: front
    steps:

      # Checkout de la rama.
      - name: Checkout code 
        uses: actions/checkout@v3

      # Crea los archivos necesarios para los siguientes pasos.
      - name: file creation
        working-directory: src
        run: |

          # Crea los secretos para que Terraform se conecte a GCP.
          echo -n '${{ secrets.GOOGLE_CREDENTIALS }}' > terraform/gcloud-key.json

          # Guarda el token en un archivo para que lo utilice Terraform.
          echo -n '${{ secrets.CLOUDFLARE_TF_TOKEN }}' > terraform/cloudflare-token.txt

          # Crea los secretos para el certificado TLS.
          echo -n '${{ secrets.TLS_SECRET_YAML }}' > k8s/tls-secrets.yaml

          # Crea los secretos de Cloudflare para cert-manager.
          echo -n '${{ secrets.CLOUDFLARE_SECRET_YAML }}' > k8s/04-tls/dns01/01-cloudflare-secrets.yaml

      # Instala y configura Terraform CLI.
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2

      # Configura Google Cloud.
      - name: Google Cloud authentication
        uses: google-github-actions/auth@v1
        with:
          credentials_json: ${{ secrets.GOOGLE_CREDENTIALS }}
      - name: Google Cloud SDK setup
        uses: google-github-actions/setup-gcloud@v1
        with:
          version: '>= 363.0.0'
          install_components: 'kubectl'
      - name: GCloud config
        run: |
          gcloud info

          gcloud components list

          gcloud container clusters get-credentials primary --region=us-central1-a

      # Destruye la infraestructura en la nube.
      - name: Terraform destroy state/dns
        working-directory: src/terraform
        run: |

          sudo apt-get install jq
        
          LOADBALANCER_IP=$(kubectl get -o json service nginx-ingress --namespace=nginx-ingress | jq -r .status.loadBalancer.ingress\[0\].ip)

          export TF_VAR_LOADBALANCER_IP=$LOADBALANCER_IP

          terraform init --reconfigure \
          --backend-config bucket="spgda-bucket" \
          --backend-config prefix="state/dns" \
          --backend-config credentials=$(dirname $(pwd))"/gcloud-key.json"

          terraform destroy -lock=false --auto-approve

      # Destruye la infraestructura en la nube.
      - name: Terraform destroy state/base
        working-directory: src/terraform/00-base
        run: |
          ls -lah

          terraform init --reconfigure \
          --backend-config bucket="spgda-bucket" \
          --backend-config prefix="state/base" \
          --backend-config credentials=$(dirname $(pwd))"/gcloud-key.json"

          terraform destroy -lock=false --auto-approve